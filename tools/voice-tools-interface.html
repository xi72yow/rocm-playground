
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice Agent</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
            background-color: #1a1a1a;
            color: #ffffff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .main-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 2rem;
        }

        .status-container {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            padding: 0.25em;
            background-color: rgb(99, 99, 99);
            border-radius: 0.25em;
            width: 85px;
            transition: all 0.3s ease;
        }

        .status-container.recording {
            background-color: rgb(80, 80, 80);
        }

        .status-container.processing {
            background-color: rgb(60, 60, 60);
        }

        .status-container.speaking {
            background-color: rgb(40, 80, 40);
        }

        .recording-circle {
            background-color: #666;
            width: 1em;
            height: 1em;
            border-radius: 50%;
            margin-right: 0.25em;
            transition: all 0.3s ease;
        }

        .recording-circle.active {
            background-color: red;
            animation: ease pulse 2s infinite;
        }

        .recording-circle.processing {
            background-color: #ffa500;
            animation: ease pulse 1s infinite;
        }

        .recording-circle.speaking {
            background-color: #00ff00;
            animation: ease speaking-pulse 0.8s infinite;
        }

        @keyframes speaking-pulse {
            0% {
                background-color: #00ff00;
                transform: scale(1);
            }
            50% {
                background-color: #66ff66;
                transform: scale(1.1);
            }
            100% {
                background-color: #00ff00;
                transform: scale(1);
            }
        }

        .recording-text {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
            font-size: 0.75em;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        @keyframes pulse {
            0% {
                background-color: red;
            }
            50% {
                background-color: #f06c6c;
            }
            100% {
                background-color: red;
            }
        }


    </style>
</head>
<body>
    <div class="main-container">
        <div class="status-container" id="statusContainer">
            <div class="recording-circle" id="recordingCircle"></div>
            <div class="recording-text" id="recordingText">Bereit</div>
        </div>
    </div>

    <script>
        class VoiceAgent {
            constructor() {
                this.recognition = null;
                this.isRecording = false;
                this.synthesis = window.speechSynthesis;
                this.voices = [];
                this.selectedVoice = null;
                this.conversationHistory = [];
                
                this.setupSpeechRecognition();
                this.setupTextToSpeech();
                this.setupEventListeners();
                this.log('System initialisiert', 'info');
            }

            log(message, type = 'info', data = null) {
                const timestamp = new Date().toLocaleTimeString('de-DE');
                console.log(`[${timestamp}] ${message}`, data);
            }

            setupSpeechRecognition() {
                if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                    this.recognition = new SpeechRecognition();
                    
                    this.recognition.continuous = true;
                    this.recognition.interimResults = true;
                    this.recognition.lang = 'de-DE';
                    
                    this.recognition.onstart = () => {
                        this.isRecording = true;
                        this.updateStatus('recording', 'Aufnahme');
                        this.log('Spracherkennung gestartet', 'success');
                    };
                    
                    this.recognition.onresult = (event) => {
                        let interimTranscript = '';
                        let finalTranscript = '';
                        
                        this.log('Spracherkennung Ergebnis', 'info', { 
                            resultIndex: event.resultIndex, 
                            resultsLength: event.results.length 
                        });
                        
                        for (let i = event.resultIndex; i < event.results.length; i++) {
                            const transcript = event.results[i][0].transcript;
                            const isFinal = event.results[i].isFinal;
                            
                            this.log('Transkription Teil', 'info', { 
                                transcript: transcript, 
                                isFinal: isFinal 
                            });
                            
                            if (isFinal) {
                                finalTranscript += transcript;
                            } else {
                                interimTranscript += transcript;
                            }
                        }
                        
                        if (finalTranscript) {
                            this.log('Finale Transkription erhalten', 'success', { text: finalTranscript });
                            this.processVoiceCommand(finalTranscript);
                        } else if (interimTranscript) {
                            this.log('Interim Transkription', 'info', { text: interimTranscript });
                        }
                    };
                    
                    this.recognition.onerror = (event) => {
                        this.log('Spracherkennungsfehler', 'error', { error: event.error });
                        this.stopRecording();
                    };
                    
                    this.recognition.onend = () => {
                        this.log('Spracherkennung beendet', 'info');
                        this.stopRecording();
                    };
                    
                    this.log('Spracherkennung konfiguriert', 'info');
                } else {
                    this.log('Spracherkennung nicht unterstÃ¼tzt', 'error');
                }
            }

            setupTextToSpeech() {
                if ('speechSynthesis' in window) {
                    speechSynthesis.onvoiceschanged = () => {
                        this.loadVoices();
                    };
                    this.loadVoices();
                    this.log('Text-to-Speech konfiguriert', 'info');
                } else {
                    this.log('Text-to-Speech nicht unterstÃ¼tzt', 'error');
                }
            }

            loadVoices() {
                this.voices = speechSynthesis.getVoices();
                const germanVoices = this.voices.filter(voice => voice.lang.startsWith('de'));
                this.selectedVoice = germanVoices.length > 0 ? germanVoices[0] : this.voices[0];
                this.log('Stimmen geladen', 'info', { 
                    total: this.voices.length, 
                    german: germanVoices.length,
                    selected: this.selectedVoice?.name 
                });
            }

            setupEventListeners() {
                // Keyboard Events
                document.addEventListener('keydown', (e) => {
                    if (e.code === 'Space' && !this.isRecording && !e.target.matches('input, textarea, select')) {
                        e.preventDefault();
                        this.startRecording();
                    }
                });
                document.addEventListener('keyup', (e) => {
                    if (e.code === 'Space' && this.isRecording) {
                        e.preventDefault();
                        this.stopRecording();
                    }
                });
                
                this.log('Event Listeners konfiguriert', 'info');
            }

            startRecording() {
                if (this.recognition && !this.isRecording) {
                    try {
                        this.recognition.start();
                        this.log('Aufnahme gestartet', 'info');
                    } catch (error) {
                        this.log('Fehler beim Starten der Aufnahme', 'error', { error: error.message });
                    }
                }
            }

            stopRecording() {
                if (this.recognition && this.isRecording) {
                    try {
                        this.recognition.stop();
                        this.isRecording = false;
                        this.updateStatusAfterRecording();
                        this.log('Aufnahme gestoppt', 'info');
                    } catch (error) {
                        this.log('Fehler beim Stoppen der Aufnahme', 'error', { error: error.message });
                        this.isRecording = false;
                        this.updateStatus('ready', 'Bereit');
                    }
                }
            }

            updateStatus(state, text) {
                const container = document.getElementById('statusContainer');
                const circle = document.getElementById('recordingCircle');
                const textElement = document.getElementById('recordingText');
                
                // Alle Klassen entfernen
                container.classList.remove('recording', 'processing', 'speaking');
                circle.classList.remove('active', 'processing', 'speaking');
                
                if (state === 'recording') {
                    container.classList.add('recording');
                    circle.classList.add('active');
                } else if (state === 'processing') {
                    container.classList.add('processing');
                    circle.classList.add('processing');
                } else if (state === 'speaking') {
                    container.classList.add('speaking');
                    circle.classList.add('speaking');
                }
                
                textElement.textContent = text;
            }

            updateStatusAfterRecording() {
                this.updateStatus('processing', 'Verarbeite');
                
                // Nach 2 Sekunden zurÃ¼ck zu "Bereit"
                setTimeout(() => {
                    this.updateStatus('ready', 'Bereit');
                }, 2000);
            }

            async processVoiceCommand(text) {
                try {
                    this.log('Sprachbefehl verarbeitet', 'info', { input: text });
                    
                    const response = await fetch('http://localhost:11434/api/chat', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            model: 'gpt-oss',
                            messages: [
                                ...this.conversationHistory,
                                { 
                                    role: 'system', 
                                    content: `Du bist ein sarkastischer kÃ¶niglicher Berater. 
                                    Antworte IMMER auf Deutsch, auch wenn der Benutzer Englisch spricht.
                                    Sei hÃ¶flich aber sarkastisch, wie ein erfahrener Berater der schon alles gesehen hat.
                                    Verwende gehobene aber nicht zu fÃ¶rmliche Sprache.
                                    
                                    WICHTIG: Gib NUR sprechfertigen Text aus!
                                    - KEINE Listen mit Bindestrichen oder Sternchen
                                    - KEINE Emoticons, Emojis oder Sonderzeichen
                                    - KEINE Markdown-Formatierung
                                    - KEINE ZeilenumbrÃ¼che
                                    - KEINE Tabellen oder strukturierte Daten
                                    
                                    Gib einfach alle Daten flÃ¼ssig aus.
                                    Formuliere einen kurzen, flÃ¼ssigen Satz mit allen verfÃ¼gbaren Daten.
                                    Wenn du Tools verwendest, erklÃ¤re kurz was du machst.`
                                },
                                { role: 'user', content: text }
                            ],
                            temperature: 0.3,
                            tools: [
                                {
                                    type: 'function',
                                    function: {
                                        name: 'get_weather',
                                        description: 'Aktuelle Wetterdaten fÃ¼r einen Ort abrufen',
                                        parameters: {
                                            type: 'object',
                                            properties: {
                                                location: {
                                                    type: 'string',
                                                    description: 'Stadt oder Ort fÃ¼r Wetterdaten'
                                                }
                                            },
                                            required: ['location']
                                        }
                                    }
                                },
                                {
                                    type: 'function',
                                    function: {
                                        name: 'calculate',
                                        description: 'Mathematische Berechnungen durchfÃ¼hren',
                                        parameters: {
                                            type: 'object',
                                            properties: {
                                                expression: {
                                                    type: 'string',
                                                    description: 'Mathematischer Ausdruck (z.B. "2+2", "10*5")'
                                                }
                                            },
                                            required: ['expression']
                                        }
                                    }
                                },
                                {
                                    type: 'function',
                                    function: {
                                        name: 'get_current_time',
                                        description: 'Aktuelle Zeit und Datum abrufen',
                                        parameters: {
                                            type: 'object',
                                            properties: {
                                                timezone: {
                                                    type: 'string',
                                                    description: 'Zeitzone (optional, Standard: lokale Zeit)'
                                                }
                                            },
                                            required: []
                                        }
                                    }
                                },
                                {
                                    type: 'function',
                                    function: {
                                        name: 'control_fan',
                                        description: 'Ventilator steuern (an/aus/toggle)',
                                        parameters: {
                                            type: 'object',
                                            properties: {
                                                action: {
                                                    type: 'string',
                                                    description: 'Aktion fÃ¼r den Ventilator (an, aus, um, einschalten, ausschalten, umschalten, on, off, toggle)',
                                                    enum: ['on', 'off', 'toggle', 'an', 'aus', 'um', 'einschalten', 'ausschalten', 'umschalten', 'start', 'stop', 'wechseln']
                                                }
                                            },
                                            required: ['action']
                                        }
                                    }
                                }
                            ],
                            stream: false
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }

                    const data = await response.json();
                    this.log('Ollama Antwort erhalten', 'info', { response: data });
                    
                    const assistantMessage = data.message;
                    this.conversationHistory.push({ role: 'user', content: text });
                    
                    if (assistantMessage.tool_calls && assistantMessage.tool_calls.length > 0) {
                        this.log('Tool Calls erkannt', 'info', { toolCalls: assistantMessage.tool_calls });
                        
                        const toolResults = [];
                        for (const toolCall of assistantMessage.tool_calls) {
                            const toolResult = await this.executeTool(toolCall);
                            toolResults.push({
                                tool_call_id: toolCall.id,
                                role: 'tool',
                                content: JSON.stringify(toolResult)
                            });
                            this.log('Tool ausgefÃ¼hrt', 'success', { 
                                tool: toolCall.function.name, 
                                result: toolResult 
                            });
                        }
                        
                        // Send tool results back to get final response
                        const finalResponse = await this.getFinalResponseWithToolResults(assistantMessage, toolResults);
                        this.speakResponse(finalResponse);
                    } else {
                        this.conversationHistory.push(assistantMessage);
                        this.speakResponse(assistantMessage.content);
                    }
                    
                } catch (error) {
                    this.log('Fehler bei Sprachverarbeitung', 'error', { error: error.message });
                    this.speakResponse('Entschuldigung, da ist etwas schiefgelaufen. Versuche es nochmal!');
                }
            }

            async executeTool(toolCall) {
                const func = toolCall.function;
                const args = typeof func.arguments === 'string' ? JSON.parse(func.arguments) : func.arguments;
                
                this.log('Tool ausfÃ¼hren', 'info', { tool: func.name, arguments: args });
                
                switch (func.name) {
                    case 'get_weather':
                        return await this.getWeather(args.location);
                    case 'calculate':
                        return await this.calculate(args.expression);
                    case 'get_current_time':
                        return await this.getCurrentTime(args.timezone);
                    case 'control_fan':
                        return await this.controlFan(args.action);
                    default:
                        throw new Error(`Unbekanntes Tool: ${func.name}`);
                }
            }

            async getWeather(location) {
                try {
                    this.log('Wetter API aufrufen', 'info', { location });
                    const response = await fetch(`https://wttr.in/${encodeURIComponent(location)}?format=j1`);
                    const data = await response.json();
                    
                    const current = data.current_condition[0];
                    const weather = {
                        location: location,
                        temperature: current.temp_C + 'Â°C',
                        condition: current.lang_de ? current.lang_de[0].value : current.weatherDesc[0].value,
                        humidity: current.humidity + '%',
                        wind: current.windspeedKmph + ' km/h',
                        pressure: current.pressure + ' hPa',
                        feels_like: current.FeelsLikeC + 'Â°C'
                    };
                    
                    this.log('Wetterdaten erhalten', 'success', weather);
                    return weather;
                } catch (error) {
                    this.log('Wetter API Fehler', 'error', { error: error.message });
                    return { error: 'Wetterdaten nicht verfÃ¼gbar' };
                }
            }

            async calculate(expression) {
                try {
                    this.log('Berechnung ausfÃ¼hren', 'info', { expression });
                    
                    // Clean expression
                    let cleanExpression = expression
                        .replace(/mal/g, '*')
                        .replace(/plus/g, '+')
                        .replace(/minus/g, '-')
                        .replace(/geteilt durch/g, '/')
                        .replace(/\s+/g, '');
                    
                    // Safe evaluation
                    const result = Function('"use strict"; return (' + cleanExpression + ')')();
                    
                    if (!Number.isFinite(result)) {
                        throw new Error('UngÃ¼ltige Berechnung');
                    }
                    
                    const calculation = {
                        expression: expression,
                        result: result,
                        formatted: Number.isInteger(result) ? result.toString() : result.toFixed(2)
                    };
                    
                    this.log('Berechnung erfolgreich', 'success', calculation);
                    return calculation;
                } catch (error) {
                    this.log('Berechnungsfehler', 'error', { error: error.message });
                    return { error: 'Berechnung fehlgeschlagen' };
                }
            }

            async getCurrentTime(timezone = null) {
                try {
                    this.log('Zeit abrufen', 'info', { timezone });
                    
                    const now = new Date();
                    const timeInfo = {
                        local: now.toLocaleString('de-DE'),
                        utc: now.toUTCString(),
                        timestamp: now.getTime(),
                        timezone: timezone || 'Lokale Zeit'
                    };
                    
                    if (timezone) {
                        try {
                            timeInfo.timezone_time = now.toLocaleString('de-DE', { timeZone: timezone });
                        } catch (error) {
                            timeInfo.timezone_time = "UngÃ¼ltige Zeitzone";
                        }
                    }
                    
                    this.log('Zeitdaten erhalten', 'success', timeInfo);
                    return timeInfo;
                } catch (error) {
                    this.log('Zeitfehler', 'error', { error: error.message });
                    return { error: 'Zeitdaten nicht verfÃ¼gbar' };
                }
            }

            async controlFan(action) {
                try {
                    this.log('Ventilator-Steuerung aufrufen', 'info', { action });
                    
                    // Deutsche Aktionen zu englischen mappen
                    let mappedAction = action;
                    if (action === 'aus' || action === 'ausschalten' || action === 'stop') {
                        mappedAction = 'off';
                    } else if (action === 'an' || action === 'einschalten' || action === 'start') {
                        mappedAction = 'on';
                    } else if (action === 'um' || action === 'umschalten' || action === 'wechseln') {
                        mappedAction = 'toggle';
                    }
                    
                    this.log('Aktion gemappt', 'info', { original: action, mapped: mappedAction });
                    
                    let url;
                    switch (mappedAction) {
                        case 'on':
                            url = 'http://192.168.2.194/relay/0?turn=on';
                            break;
                        case 'off':
                            url = 'http://192.168.2.194/relay/0?turn=off';
                            break;
                        case 'toggle':
                            url = 'http://192.168.2.194/relay/0?turn=toggle';
                            break;
                        default:
                            throw new Error(`Unbekannte Aktion: ${action} (gemappt: ${mappedAction})`);
                    }
                    
                    // CORS-Proxy verwenden oder direkten Aufruf mit Error-Handling
                    let result;
                    try {
                        const response = await fetch(url, {
                            method: 'GET',
                            mode: 'no-cors', // Ignoriert CORS-Fehler
                            cache: 'no-cache'
                        });
                        result = 'OK';
                    } catch (corsError) {
                        // CORS-Fehler ignorieren, da der Server trotzdem antwortet
                        this.log('CORS-Warnung ignoriert', 'warning', corsError);
                        result = 'OK (CORS ignoriert)';
                    }
                    
                    this.log('Ventilator-Steuerung erfolgreich', 'info', { action, result });
                    
                    return {
                        success: true,
                        action: action,
                        status: result,
                        message: `Ventilator wurde ${action === 'on' ? 'eingeschaltet' : action === 'off' ? 'ausgeschaltet' : 'umgeschaltet'}`
                    };
                } catch (error) {
                    this.log('Fehler bei Ventilator-Steuerung', 'error', error);
                    return { 
                        success: false, 
                        error: `Ventilator konnte nicht ${action === 'on' ? 'eingeschaltet' : action === 'off' ? 'ausgeschaltet' : 'umgeschaltet'} werden`,
                        details: error.message 
                    };
                }
            }

            async getFinalResponseWithToolResults(assistantMessage, toolResults) {
                try {
                    this.log('Finale Antwort mit Tool-Ergebnissen anfordern', 'info');
                    
                    const response = await fetch('http://localhost:11434/api/chat', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            model: 'gpt-oss',
                            messages: [
                                ...this.conversationHistory,
                                assistantMessage,
                                ...toolResults
                            ],
                            stream: false
                        })
                    });

                    const data = await response.json();
                    this.conversationHistory.push(data.message);
                    
                    this.log('Finale Antwort erhalten', 'success', { content: data.message.content });
                    return data.message.content;
                } catch (error) {
                    this.log('Fehler bei finaler Antwort', 'error', { error: error.message });
                    return 'Entschuldigung, ich konnte keine Antwort generieren.';
                }
            }

            async getFinalResponse() {
                try {
                    this.log('Finale Antwort anfordern', 'info');
                    
                    const response = await fetch('http://localhost:11434/api/chat', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            model: 'gpt-oss',
                            messages: this.conversationHistory,
                            temperature: 0.3,
                            stream: false
                        })
                    });

                    const data = await response.json();
                    this.conversationHistory.push(data.message);
                    
                    this.log('Finale Antwort erhalten', 'success', { content: data.message.content });
                    return data.message.content;
                } catch (error) {
                    this.log('Fehler bei finaler Antwort', 'error', { error: error.message });
                    return 'Entschuldigung, ich konnte keine Antwort generieren.';
                }
            }

            speakResponse(text) {
                try {
                    // Aggressive Text-Bereinigung fÃ¼r wohlklingende Ausgabe
                    const cleanText = text
                        .replace(/\*\*(.*?)\*\*/g, '$1') // Bold entfernen
                        .replace(/\*(.*?)\*/g, '$1') // Italic entfernen
                        .replace(/`(.*?)`/g, '$1') // Code entfernen
                        .replace(/\n+/g, ' ') // ZeilenumbrÃ¼che zu Leerzeichen
                        .replace(/-\s+/g, '') // Listenpunkte entfernen
                        .replace(/\*\*/g, '') // Restliche Sternchen entfernen
                        .replace(/ðŸŒ¤ï¸|ðŸŒ¤|ðŸŒ¦ï¸|ðŸŒ¦|ðŸŒ§ï¸|ðŸŒ§|ðŸŒ©ï¸|ðŸŒ©|ðŸŒ¨ï¸|ðŸŒ¨/g, '') // Wetter-Emojis entfernen
                        .replace(/:\s+/g, ': ') // Doppelpunkte normalisieren
                        .replace(/\s*,\s*/g, ', ') // Kommas normalisieren
                        .replace(/\s*\.\s*/g, '. ') // Punkte normalisieren
                        .replace(/\s+/g, ' ') // Mehrfache Leerzeichen normalisieren
                        .replace(/^\s*[-*]\s*/gm, '') // Listenpunkte am Zeilenanfang entfernen
                        .replace(/\s+/g, ' ') // Nochmal Leerzeichen normalisieren
                        .trim();
                    
                    this.log('TTS starten', 'info', { original: text, cleaned: cleanText });
                    
                    if (this.synthesis && this.selectedVoice) {
                        const utterance = new SpeechSynthesisUtterance(cleanText);
                        utterance.voice = this.selectedVoice;
                        utterance.lang = 'de-DE';
                        utterance.rate = 1.4; // 1.4-fache Geschwindigkeit
                        utterance.pitch = 1.0;
                        utterance.volume = 1.0;
                        
                        utterance.onstart = () => {
                            this.updateStatus('speaking', 'Spreche');
                            this.log('TTS gestartet', 'success');
                        };
                        
                        utterance.onend = () => {
                            this.updateStatus('ready', 'Bereit');
                            this.log('TTS beendet', 'info');
                        };
                        
                        utterance.onerror = (error) => {
                            this.updateStatus('ready', 'Bereit');
                            this.log('TTS Fehler', 'error', { error: error.error });
                        };
                        
                        this.synthesis.speak(utterance);
                    } else {
                        this.log('TTS nicht verfÃ¼gbar', 'warning');
                    }
                } catch (error) {
                    this.log('TTS Fehler', 'error', { error: error.message });
                }
            }


        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new VoiceAgent();
        });
    </script>
</body>
</html>